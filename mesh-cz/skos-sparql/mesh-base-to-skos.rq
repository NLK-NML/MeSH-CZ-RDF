### Conversion of MeSH *base* dataset [with translation] to SKOS dataset
##  - version 1.1.0 2026-01-27
## Run the query - using either method:
# a. Copy this file to Apache Jena data dir, STOP Fuseki instance, and run:
#  tdb2_tdbquery --loc=databases/mesh --query=mesh-base-to-skos.rq --time > mesh-skos-base.ttl
##  Or
# b. Copy this file to a dir where the MeSH nq gzipped dataset is located and run:
#  arq --query=mesh-base-to-skos.rq --data=mesh-cz.nq.gz --time > mesh-skos-base.ttl
#
PREFIX mesh:   <http://id.nlm.nih.gov/mesh/>
PREFIX meshv:  <http://id.nlm.nih.gov/mesh/vocab#>
PREFIX mesht:  <http://www.medvik.cz/schema/mesh/vocab/#>
PREFIX meshcz: <http://mesh.medvik.cz/meshcz/>
PREFIX rdf:    <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs:   <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skos:   <http://www.w3.org/2004/02/skos/core#>

CONSTRUCT {
  # Descriptor triples
  ?d a skos:Concept, ?type ;
     skos:prefLabel ?plabel, ?tplabel ;
     skos:broader ?broader ;
     skos:broader ?topConcept ;
     skos:narrower ?narrower ;
     skos:related ?related ;
     skos:changeNote ?previousIndexing ;
     skos:exactMatch ?exactMatch ;
     skos:inScheme mesh: ;
     skos:definition ?qlabel, ?qtlabel .

  ?topConcept skos:narrower ?d .

  meshcz:scheme a skos:ConceptScheme ;
        skos:hasTopConcept ?topConcept .

  mesh: a skos:ConceptScheme ;
        skos:prefLabel "Medical Subject Headings 2026 CZ"@en .
}
WHERE {

  # Bind the descriptor for testing
  #BIND(mesh:D001829 AS ?d)
  #BIND(mesh:D018153 AS ?d)
  #BIND(mesh:D004232 AS ?d)
  #BIND(mesh:Q000453 AS ?d)
  #BIND(mesh:D001829 AS ?d)

  VALUES ?type {
    meshv:TopicalDescriptor
    meshv:GeographicalDescriptor
    meshv:PublicationType
    meshv:CheckTag
    meshv:Qualifier
  }

  ?d rdf:type ?type .
  FILTER NOT EXISTS { ?d meshv:active false }
  ?d meshv:preferredConcept ?c .
  FILTER NOT EXISTS { ?c meshv:active false }
  ?d meshv:identifier ?id .

  # Exact match link
  BIND(IRI(CONCAT("https://www.medvik.cz/link/", ?id)) AS ?exactMatch)

  # Preferred labels
  ?d meshv:preferredTerm ?pt .
  ?pt meshv:prefLabel ?plabel .
  OPTIONAL {
    ?c mesht:preferredTerm ?ptt .
    ?ptt mesht:prefLabel ?tplabel
  }

  # Qualifiers
  OPTIONAL {
    ?d meshv:allowableQualifier ?q .
    FILTER NOT EXISTS { ?q meshv:active false }
    ?q meshv:preferredTerm ?qt .
    ?qt meshv:prefLabel ?qlabel
  }
  OPTIONAL {
    ?d meshv:allowableQualifier ?q .
    FILTER NOT EXISTS { ?q meshv:active false }
    ?q meshv:preferredConcept ?qc .
    ?qc mesht:preferredTerm ?qtt .
    ?qtt mesht:prefLabel ?qtlabel
  }

  # Hierarchy
  OPTIONAL { ?d meshv:broaderDescriptor ?broader
              FILTER NOT EXISTS { ?broader meshv:active false }
           }
  OPTIONAL { ?d meshv:broaderQualifier ?broader
              FILTER NOT EXISTS { ?broader meshv:active false }
           }
  OPTIONAL { ?narrower meshv:broaderDescriptor ?d
             FILTER NOT EXISTS { ?narrower meshv:active false }
           }
  OPTIONAL { ?narrower meshv:broaderQualifier ?d
             FILTER NOT EXISTS { ?narrower meshv:active false }
           }

  # Related concepts
  OPTIONAL { ?d meshv:seeAlso ?related
             FILTER NOT EXISTS { ?related meshv:active false }
            }

  # Previous indexing
  OPTIONAL { ?d meshv:previousIndexing ?previousIndexing }

  # Top-level category derivation
  OPTIONAL {
    ?d meshv:treeNumber ?tn .
    FILTER NOT EXISTS { ?tn meshv:active false }
    ?tn rdfs:label ?treeNumber .
    FILTER (STRLEN(?treeNumber) = 3)
    FILTER NOT EXISTS { ?d meshv:broaderDescriptor ?brd }

    # Extract leading letter
    BIND(SUBSTR(?treeNumber, 1, 1) AS ?topLetter)
    BIND(IRI(CONCAT(STR(meshcz:), ?topLetter)) AS ?topConcept)
  }

}

#LIMIT 10000
